/* tslint:disable */
/* eslint-disable */
/*
Terminal API

Terminal is a unified API that makes it easy to integrate with the leading telematics service providers.

Contact Support:
 Name: Terminal
 Email: connect@withterminal.com

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * IssuesApi - axios parameter creator
 * @export
 */
export const IssuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all issues that have been observed by Terminal. Issues are generated when we observe something that may impact the completeness or accuracy of the data we provide but do not justify a full error. For example, if we lack permissions for a specific resource or need to skip an item due to invalid data.
         * @summary List Issues
         * @param {string} [limit] The maximum number of results to return in a page.
         * @param {string} [cursor] Pagination cursor to start requests from
         * @param {string} [lastReportedAfter] Timestamp to start when the issue was last observed
         * @param {string} [lastReportedBefore] Timestamp to end when the issue was last observed
         * @param {string} [expand] Expand related resources to see all details
         * @param {string} [connectionId] Filter issues to a specific connection
         * @param {string} [errorCode] Filter issues to a specific error code
         * @param {string} [status] Filter issues to a specific status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObservedEvents: async (limit?: string, cursor?: string, lastReportedAfter?: string, lastReportedBefore?: string, expand?: string, connectionId?: string, errorCode?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (lastReportedAfter !== undefined) {
                localVarQueryParameter['lastReportedAfter'] = lastReportedAfter;
            }

            if (lastReportedBefore !== undefined) {
                localVarQueryParameter['lastReportedBefore'] = lastReportedBefore;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (connectionId !== undefined) {
                localVarQueryParameter['connectionId'] = connectionId;
            }

            if (errorCode !== undefined) {
                localVarQueryParameter['errorCode'] = errorCode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/issues',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark an issue\'s status as `resolved` until the issue is observed again.
         * @summary Resolve Issue
         * @param {string} issueId (Required) 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markResolved: async (issueId: string, body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('markResolved', 'issueId', issueId)
            const localVarPath = `/issues/{issueId}/resolve`
                .replace(`{${"issueId"}}`, encodeURIComponent(String(issueId !== undefined ? issueId : `-issueId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/issues/{issueId}/resolve',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssuesApi - functional programming interface
 * @export
 */
export const IssuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssuesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all issues that have been observed by Terminal. Issues are generated when we observe something that may impact the completeness or accuracy of the data we provide but do not justify a full error. For example, if we lack permissions for a specific resource or need to skip an item due to invalid data.
         * @summary List Issues
         * @param {IssuesApiListObservedEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listObservedEvents(requestParameters: IssuesApiListObservedEventsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listObservedEvents(requestParameters.limit, requestParameters.cursor, requestParameters.lastReportedAfter, requestParameters.lastReportedBefore, requestParameters.expand, requestParameters.connectionId, requestParameters.errorCode, requestParameters.status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark an issue\'s status as `resolved` until the issue is observed again.
         * @summary Resolve Issue
         * @param {IssuesApiMarkResolvedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markResolved(requestParameters: IssuesApiMarkResolvedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const body: object = {
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.markResolved(requestParameters.issueId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IssuesApi - factory interface
 * @export
 */
export const IssuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssuesApiFp(configuration)
    return {
        /**
         * List all issues that have been observed by Terminal. Issues are generated when we observe something that may impact the completeness or accuracy of the data we provide but do not justify a full error. For example, if we lack permissions for a specific resource or need to skip an item due to invalid data.
         * @summary List Issues
         * @param {IssuesApiListObservedEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObservedEvents(requestParameters: IssuesApiListObservedEventsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listObservedEvents(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark an issue\'s status as `resolved` until the issue is observed again.
         * @summary Resolve Issue
         * @param {IssuesApiMarkResolvedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markResolved(requestParameters: IssuesApiMarkResolvedRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markResolved(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listObservedEvents operation in IssuesApi.
 * @export
 * @interface IssuesApiListObservedEventsRequest
 */
export type IssuesApiListObservedEventsRequest = {
    
    /**
    * The maximum number of results to return in a page.
    * @type {string}
    * @memberof IssuesApiListObservedEvents
    */
    readonly limit?: string
    
    /**
    * Pagination cursor to start requests from
    * @type {string}
    * @memberof IssuesApiListObservedEvents
    */
    readonly cursor?: string
    
    /**
    * Timestamp to start when the issue was last observed
    * @type {string}
    * @memberof IssuesApiListObservedEvents
    */
    readonly lastReportedAfter?: string
    
    /**
    * Timestamp to end when the issue was last observed
    * @type {string}
    * @memberof IssuesApiListObservedEvents
    */
    readonly lastReportedBefore?: string
    
    /**
    * Expand related resources to see all details
    * @type {string}
    * @memberof IssuesApiListObservedEvents
    */
    readonly expand?: string
    
    /**
    * Filter issues to a specific connection
    * @type {string}
    * @memberof IssuesApiListObservedEvents
    */
    readonly connectionId?: string
    
    /**
    * Filter issues to a specific error code
    * @type {string}
    * @memberof IssuesApiListObservedEvents
    */
    readonly errorCode?: string
    
    /**
    * Filter issues to a specific status
    * @type {string}
    * @memberof IssuesApiListObservedEvents
    */
    readonly status?: string
    
}

/**
 * Request parameters for markResolved operation in IssuesApi.
 * @export
 * @interface IssuesApiMarkResolvedRequest
 */
export type IssuesApiMarkResolvedRequest = {
    
    /**
    * (Required) 
    * @type {string}
    * @memberof IssuesApiMarkResolved
    */
    readonly issueId: string
    
} & object

/**
 * IssuesApiGenerated - object-oriented interface
 * @export
 * @class IssuesApiGenerated
 * @extends {BaseAPI}
 */
export class IssuesApiGenerated extends BaseAPI {
    /**
     * List all issues that have been observed by Terminal. Issues are generated when we observe something that may impact the completeness or accuracy of the data we provide but do not justify a full error. For example, if we lack permissions for a specific resource or need to skip an item due to invalid data.
     * @summary List Issues
     * @param {IssuesApiListObservedEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiGenerated
     */
    public listObservedEvents(requestParameters: IssuesApiListObservedEventsRequest = {}, options?: AxiosRequestConfig) {
        return IssuesApiFp(this.configuration).listObservedEvents(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark an issue\'s status as `resolved` until the issue is observed again.
     * @summary Resolve Issue
     * @param {IssuesApiMarkResolvedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiGenerated
     */
    public markResolved(requestParameters: IssuesApiMarkResolvedRequest, options?: AxiosRequestConfig) {
        return IssuesApiFp(this.configuration).markResolved(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
